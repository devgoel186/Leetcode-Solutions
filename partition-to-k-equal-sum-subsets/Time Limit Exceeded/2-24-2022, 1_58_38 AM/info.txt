{"id":647658946,"lang":"cpp","time":"1 month, 2 weeks","timestamp":1645648118,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/647658946/","is_pending":"Not Pending","title":"Partition to K Equal Sum Subsets","memory":"N/A","code":"// class Solution {\n//     private:\n//     int x = 0;\n    \n//     bool dfs(vector<int> &m, vector<bool> &visited, int i, int sum, int k)\n//     { \n//         if(k == 0)\n//             return true;\n        \n//         if(sum == 0)\n//             return dfs(m, visited, 0, x / k, k - 1);\n        \n//         for(int j = i; j < m.size(); j++)\n//         {\n//             if(visited[j] || (sum - m[j] < 0))\n//                 continue;\n            \n//             visited[j] = true;\n            \n//             if(dfs(m, visited, j + 1, sum - m[j], k))\n//                 return true;\n            \n//             visited[j] = false;\n//         }\n        \n//         return false;\n//     }\n    \n//     public:\n//     bool canPartitionKSubsets(vector<int>& nums, int k) {\n//         int n = nums.size();\n//         for(auto i : nums)\n//             x += i;\n    \n//         if((n < k) || (x % k != 0))\n//             return false;\n        \n//         vector<bool> visited(n, false);\n        \n//         return dfs(nums, visited, 0, x / k, k - 1);\n//     }\n// };\n\nclass Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        int sum = 0;\n        sum = accumulate(nums.begin(), nums.end(), sum);\n        if (nums.size() < k || sum % k) return false;\n        \n        vector<int>visited(nums.size(), false);\n        return backtrack(nums, visited, sum / k, 0, 0, k);\n    }\n    \n    bool backtrack(vector<int>& nums,vector<int>visited, int target, int curr_sum, int i, int k) {\n        if (k == 1) \n            return true;\n        \n        if (curr_sum == target) \n            return backtrack(nums, visited, target, 0, 0, k-1);\n        \n        for (int j = i; j < nums.size(); j++) {\n            if (visited[j] || curr_sum + nums[j] > target) continue;\n            \n            visited[j] = true;\n            if (backtrack(nums, visited, target, curr_sum + nums[j], j+1, k)) return true;\n            visited[j] = false;\n        }\n        \n        return false;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000","title_slug":"partition-to-k-equal-sum-subsets"}