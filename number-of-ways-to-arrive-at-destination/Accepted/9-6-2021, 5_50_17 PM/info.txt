{"id":550348451,"lang":"cpp","time":"7 months, 1 week","timestamp":1630930817,"status_display":"Accepted","runtime":"80 ms","url":"/submissions/detail/550348451/","is_pending":"Not Pending","title":"Number of Ways to Arrive at Destination","memory":"35.7 MB","code":"#define ll long long\n#define pll pair<ll, ll>\nclass Solution {\npublic:\n    const ll MOD = 1e9 + 7;\n    /*\n    int dijkstra(int n, int src, vector<vector<pair<ll, ll>>> &adjl)\n    {   \n        vector<ll> dist(n, INT_MAX), count(n, 0);\n        dist[src] = 0;\n        count[src] = 1;\n        \n        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\n        pq.push({0, src});\n        \n        while(!pq.empty())\n        {\n            pair<ll, ll> x = pq.top();\n            pq.pop();\n            ll u = x.second;\n            \n            if(x.first > dist[u])\n                continue;\n            \n            for(auto i : adjl[u])\n            {\n                ll v = i.first;\n                ll w = i.second;                \n\n                if(dist[v] > dist[u] + w)\n                {\n                    dist[v] = dist[u] + w;\n                    pq.push({dist[v], v});\n                    count[v] = count[u];\n                }\n                else if(dist[v] == dist[u] + w)\n                {\n                    count[v] = (count[v] % MOD + count[u] % MOD) % MOD;\n                }\n            }\n        }\n        \n        return (int)count[n - 1] % MOD;\n    }\n    */\n    \n    int dijkstra(const vector<vector<pll>>& graph, int n, int src) {\n        vector<ll> dist(n, LONG_MAX);\n        vector<ll> ways(n);\n        ways[src] = 1;\n        dist[src] = 0;\n        priority_queue<pll, vector<pll>, greater<>> minHeap;\n        minHeap.push({0, 0}); // dist, src\n        while (!minHeap.empty()) {\n            auto[d, u] = minHeap.top(); minHeap.pop();\n            if (d > dist[u]) continue; // Skip if `d` is not updated to latest version!\n            for(auto [v, time] : graph[u]) {\n                if (dist[v] > d + time) {\n                    dist[v] = d + time;\n                    ways[v] = ways[u];\n                    minHeap.push({dist[v], v});\n                } else if (dist[v] == d + time) {\n                    ways[v] = (ways[v] + ways[u]) % MOD;\n                }\n            }\n        }\n        return ways[n-1];\n    }\n    \n    int countPaths(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<ll, ll>>> adjl(n);\n        \n        for(auto i : roads)\n        {\n            adjl[i[0]].push_back({i[1], i[2]});\n            adjl[i[1]].push_back({i[0], i[2]});\n        }\n        \n        return dijkstra(adjl, n, 0);\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111","title_slug":"number-of-ways-to-arrive-at-destination"}